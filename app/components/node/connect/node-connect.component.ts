import { Component, Input, OnInit } from "@angular/core";
import { autobind } from "@batch-flask/core";
import { List } from "immutable";
import * as moment from "moment";

import { SidebarRef } from "@batch-flask/ui/sidebar";
import { Node, NodeAgentSku, NodeConnectionSettings, Pool } from "app/models";
import {
    AddNodeUserAttributes,
    BatchLabsService,
    NodeService,
    NodeUserService,
    SSHKeyService,
    SettingsService,
} from "app/services";
import { DateUtils, PoolUtils, SecureUtils } from "app/utils";
import { Application } from "common/constants";
import { Observable } from "rxjs";
import { flatMap, share, tap } from "rxjs/operators";
import "./node-connect.scss";

enum CredentialSource {
    Generated,
    Specified,
}

@Component({
    selector: "bl-node-connect",
    templateUrl: "node-connect.html",
})
export class NodeConnectComponent implements OnInit {
    public CredentialSource = CredentialSource;
    public credentialSource: CredentialSource = null;
    public credentials: AddNodeUserAttributes = null;
    public agentSkus: List<NodeAgentSku>;
    public windows = false;
    public linux = false;
    public hasIp = false;
    public expireTime: string;
    public hasLocalPublicKey: boolean;
    public defaultUsername: string;
    public quickStartTooltip: string = "";

    /**
     * Base content for the rdp file(IP Address).
     * This is either downloaded from the api on CloudService nodes or generated from the ip/port on VMs nodes
     */
    public rdpContent: string;
    public connectionSettings: NodeConnectionSettings;

    @Input()
    public set pool(pool: Pool) {
        this._pool = pool;
        if (pool) {
            this.hasIp = Boolean(pool.virtualMachineConfiguration);
            this.linux = PoolUtils.isLinux(this.pool);
            this._loadConnectionData();
        }
    }
    public get pool() { return this._pool; }

    @Input()
    public set node(node: Node) {
        this._node = node;
        if (node) {
            this._loadConnectionData();
        }
    }
    public get node() { return this._node; }

    private _pool: Pool;
    private _node: Node;

    constructor(
        public sidebarRef: SidebarRef<any>,
        public settingsService: SettingsService,
        private nodeUserService: NodeUserService,
        private nodeService: NodeService,
        private batchLabs: BatchLabsService,
        private sshKeyService: SSHKeyService,
    ) {
        this.defaultUsername = settingsService.settings["username"];
        this.quickStartTooltip = "No SSH Keys Found";
    }

    public ngOnInit() {
        const data = this.nodeService.listNodeAgentSkus();
        data.fetchAll().subscribe(() => {
            data.items.take(1).subscribe((agentSkus) => {
                this.agentSkus = agentSkus;
                this.windows = PoolUtils.isWindows(this.pool, agentSkus);
                data.dispose();
            });
        });

        this.sshKeyService.hasLocalPublicKey().subscribe(hasKey => this.hasLocalPublicKey = hasKey);
    }

    @autobind()
    public generateCredentials() {
        const credentials = {
            name: SecureUtils.username(),
            password: SecureUtils.password(),
            isAdmin: true,
        };

        return this.addOrUpdateUser(credentials).do(() => {
            this.credentialSource = CredentialSource.Generated;
            this.expireTime = DateUtils.fullDateAndTime(moment().add(24, "hours").toDate());
        });
    }

    @autobind()
    public generateWithOneClick() {
        // Todo use observable for this
        if (!this.connectionSettings) {
            return null;
        }

        const credentials = {
            name: this.defaultUsername ? this.defaultUsername : SecureUtils.username(),
            isAdmin: true,
            expiryTime:  moment().add(moment.duration({days: 1})).toDate(),
            sshPublicKey: "",
        };

        // fetch the public key from the user's filesystem
        const obs =  this.sshKeyService.getLocalPublicKey().pipe(
            flatMap((key) => {
                this.credentialSource = CredentialSource.Generated; // set the credentials source to be autogenerated
                credentials.sshPublicKey = key;                     // set the key to be the fetched public key
                this.credentials = credentials;
                return this.addOrUpdateUser(credentials);           // set the user that will be used for authentication
            }),
            flatMap(() => {
                // launch a terminal subprocess with the command to access the node
                const args = {
                    command: PoolUtils.isWindows(this.pool) ? "" : this.sshCommand,
                };
                // TODO insert rdpCommand as a get method and place in ternary statement above
                return Observable.fromPromise(this.batchLabs.launchApplication(Application.terminal, args));
            }),
            share(),
        );
        obs.subscribe({
            error: (error) => {
                throw error;
            },
        });
        return obs;
    }

    @autobind()
    public addOrUpdateUser(credentials) {
        return this.nodeUserService.addOrUpdateUser(this.pool.id, this.node.id, credentials).pipe(
            tap(() => {
                this.credentials = credentials;
                this.expireTime = DateUtils.fullDateAndTime(this.credentials.expiryTime);
            }),
        );
    }

    public get sshCommand() {
        if (!this.connectionSettings || !this.credentials) {
            return "N/A";
        }
        const { ip, port } = this.connectionSettings;
        return `ssh ${this.credentials.name}@${ip} -p ${port}`;
    }

    @autobind()
    public specifyCredentials() {
        this.credentialSource = CredentialSource.Specified;
    }

    @autobind()
    public goToHome() {
        this.credentialSource = null;
    }

    @autobind()
    public close() {
        this.sidebarRef.destroy();
    }

    /**
     * Load either the RDP file or the node connection settings depending if the VM is IAAS or PAAS
     */
    private _loadConnectionData() {
        if (!this.pool || !this.node) { return; }
        if (PoolUtils.isPaas(this.pool)) {
            this.nodeService.getRemoteDesktop(this.pool.id, this.node.id).subscribe((rdp) => {
                this.rdpContent = rdp;
            });
        } else {
            this.nodeService.getRemoteLoginSettings(this.pool.id, this.node.id).subscribe((connection) => {
                this.connectionSettings = connection;
            });
        }
    }
}
